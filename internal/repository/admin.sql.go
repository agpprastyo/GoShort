// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: admin.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const adminGetShortLinkByID = `-- name: AdminGetShortLinkByID :one
SELECT id, user_id, original_url, short_code, title, is_active, click_limit, expired_at, created_at, updated_at FROM short_links
WHERE id = $1::uuid
`

func (q *Queries) AdminGetShortLinkByID(ctx context.Context, id uuid.UUID) (ShortLink, error) {
	row := q.db.QueryRow(ctx, adminGetShortLinkByID, id)
	var i ShortLink
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OriginalUrl,
		&i.ShortCode,
		&i.Title,
		&i.IsActive,
		&i.ClickLimit,
		&i.ExpiredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const adminGetShortLinksByUserID = `-- name: AdminGetShortLinksByUserID :many
SELECT id, user_id, original_url, short_code, title, is_active, click_limit, expired_at, created_at, updated_at FROM short_links
WHERE user_id = $1
  -- Search functionality - search by title (handles NULL titles)
  AND ($4::text = '' OR (title IS NOT NULL AND title ILIKE '%' || $4 || '%'))
  -- Date range filtering for created_at
  AND ($5::timestamptz IS NULL OR created_at >= $5)
  AND ($6::timestamptz IS NULL OR created_at <= $6)
ORDER BY
    CASE
        WHEN $7::shortlink_order_column = 'title' AND $8::bool = true THEN title
END ASC NULLS LAST,
    CASE
        WHEN $7::shortlink_order_column = 'title' AND $8::bool = false THEN title
END DESC NULLS LAST,
    CASE
        WHEN $7::shortlink_order_column = 'is_active' AND $8::bool = true THEN is_active::int
END ASC,
    CASE
        WHEN $7::shortlink_order_column = 'is_active' AND $8::bool = false THEN is_active::int
END DESC,
    CASE
        WHEN $7::shortlink_order_column = 'created_at' AND $8::bool = true THEN created_at
END ASC,
    CASE
        WHEN $7::shortlink_order_column = 'created_at' AND $8::bool = false THEN created_at
END DESC,
    CASE
        WHEN $7::shortlink_order_column = 'updated_at' AND $8::bool = true THEN updated_at
END ASC,
    CASE
        WHEN $7::shortlink_order_column = 'updated_at' AND $8::bool = false THEN updated_at
END DESC,
    CASE
        WHEN $7::shortlink_order_column = 'expired_at' AND $8::bool = true THEN expired_at
END ASC NULLS LAST,
    CASE
        WHEN $7::shortlink_order_column = 'expired_at' AND $8::bool = false THEN expired_at
END DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type AdminGetShortLinksByUserIDParams struct {
	UserID     uuid.UUID            `json:"user_id"`
	Limit      int64                `json:"limit"`
	Offset     int64                `json:"offset"`
	SearchText string               `json:"search_text"`
	StartDate  pgtype.Timestamptz   `json:"start_date"`
	EndDate    pgtype.Timestamptz   `json:"end_date"`
	OrderBy    ShortlinkOrderColumn `json:"order_by"`
	Ascending  bool                 `json:"ascending"`
}

func (q *Queries) AdminGetShortLinksByUserID(ctx context.Context, arg AdminGetShortLinksByUserIDParams) ([]ShortLink, error) {
	rows, err := q.db.Query(ctx, adminGetShortLinksByUserID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.SearchText,
		arg.StartDate,
		arg.EndDate,
		arg.OrderBy,
		arg.Ascending,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShortLink{}
	for rows.Next() {
		var i ShortLink
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalUrl,
			&i.ShortCode,
			&i.Title,
			&i.IsActive,
			&i.ClickLimit,
			&i.ExpiredAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListShortLinks = `-- name: AdminListShortLinks :many
SELECT id, user_id, original_url, short_code, title, is_active, click_limit, expired_at, created_at, updated_at FROM short_links
    WHERE  TRUE
  -- Search functionality - search by title (handles NULL titles)
  AND ($1::text = '' OR (title IS NOT NULL AND title ILIKE '%' || $1 || '%'))
  -- Date range filtering for created_at
  AND ($4::timestamptz IS NULL OR created_at >= $4)
  AND ($5::timestamptz IS NULL OR created_at <= $5)
ORDER BY
    CASE
        WHEN $6::shortlink_order_column = 'title' AND $7::bool = true THEN title
END ASC NULLS LAST,
    CASE
        WHEN $6::shortlink_order_column = 'title' AND $7::bool = false THEN title
END DESC NULLS LAST,
    CASE
        WHEN $6::shortlink_order_column = 'is_active' AND $7::bool = true THEN is_active::int
END ASC,
    CASE
        WHEN $6::shortlink_order_column = 'is_active' AND $7::bool = false THEN is_active::int
END DESC,
    CASE
        WHEN $6::shortlink_order_column = 'created_at' AND $7::bool = true THEN created_at
END ASC,
    CASE
        WHEN $6::shortlink_order_column = 'created_at' AND $7::bool = false THEN created_at
END DESC,
    CASE
        WHEN $6::shortlink_order_column = 'updated_at' AND $7::bool = true THEN updated_at
END ASC,
    CASE
        WHEN $6::shortlink_order_column = 'updated_at' AND $7::bool = false THEN updated_at
END DESC,
    CASE
        WHEN $6::shortlink_order_column = 'expired_at' AND $7::bool = true THEN expired_at
END ASC NULLS LAST,
    CASE
        WHEN $6::shortlink_order_column = 'expired_at' AND $7::bool = false THEN expired_at
END DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type AdminListShortLinksParams struct {
	SearchText string               `json:"search_text"`
	Limit      int64                `json:"limit"`
	Offset     int64                `json:"offset"`
	StartDate  pgtype.Timestamptz   `json:"start_date"`
	EndDate    pgtype.Timestamptz   `json:"end_date"`
	OrderBy    ShortlinkOrderColumn `json:"order_by"`
	Ascending  bool                 `json:"ascending"`
}

func (q *Queries) AdminListShortLinks(ctx context.Context, arg AdminListShortLinksParams) ([]ShortLink, error) {
	rows, err := q.db.Query(ctx, adminListShortLinks,
		arg.SearchText,
		arg.Limit,
		arg.Offset,
		arg.StartDate,
		arg.EndDate,
		arg.OrderBy,
		arg.Ascending,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShortLink{}
	for rows.Next() {
		var i ShortLink
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalUrl,
			&i.ShortCode,
			&i.Title,
			&i.IsActive,
			&i.ClickLimit,
			&i.ExpiredAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminToggleShortLinkStatus = `-- name: AdminToggleShortLinkStatus :exec
UPDATE short_links
SET is_active = NOT is_active
WHERE id = $1
`

func (q *Queries) AdminToggleShortLinkStatus(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, adminToggleShortLinkStatus, id)
	return err
}
