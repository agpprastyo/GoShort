// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: links_stats_user.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getUserClickTimeline = `-- name: GetUserClickTimeline :many
SELECT
    date_trunc('day', ls.click_time)::date as click_date,
    count(ls.id)::int as clicks_count
FROM link_stats ls
         JOIN short_links sl ON ls.link_id = sl.id
WHERE
    sl.user_id = $1 AND
    ls.click_time >= $2 AND
    ls.click_time <= $3
GROUP BY click_date
ORDER BY click_date ASC
`

type GetUserClickTimelineParams struct {
	UserID      uuid.UUID          `json:"user_id"`
	ClickTime   pgtype.Timestamptz `json:"click_time"`
	ClickTime_2 pgtype.Timestamptz `json:"click_time_2"`
}

type GetUserClickTimelineRow struct {
	ClickDate   pgtype.Date `json:"click_date"`
	ClicksCount int32       `json:"clicks_count"`
}

// Mengambil data time-series jumlah klik per hari untuk pengguna tertentu dalam rentang waktu.
// Berguna untuk membuat grafik tren klik dari waktu ke waktu.
func (q *Queries) GetUserClickTimeline(ctx context.Context, arg GetUserClickTimelineParams) ([]GetUserClickTimelineRow, error) {
	rows, err := q.db.Query(ctx, getUserClickTimeline, arg.UserID, arg.ClickTime, arg.ClickTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserClickTimelineRow{}
	for rows.Next() {
		var i GetUserClickTimelineRow
		if err := rows.Scan(&i.ClickDate, &i.ClicksCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserClicksByCountry = `-- name: GetUserClicksByCountry :many
SELECT
    ls.country,
    count(ls.id)::int as clicks
FROM link_stats ls
         JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.user_id = $1 AND ls.country IS NOT NULL
GROUP BY ls.country
ORDER BY clicks DESC
`

type GetUserClicksByCountryRow struct {
	Country *string `json:"country"`
	Clicks  int32   `json:"clicks"`
}

// Mengelompokkan jumlah klik berdasarkan negara untuk semua link milik pengguna.
// Berguna untuk membuat diagram statistik geografis.
func (q *Queries) GetUserClicksByCountry(ctx context.Context, userID uuid.UUID) ([]GetUserClicksByCountryRow, error) {
	rows, err := q.db.Query(ctx, getUserClicksByCountry, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserClicksByCountryRow{}
	for rows.Next() {
		var i GetUserClicksByCountryRow
		if err := rows.Scan(&i.Country, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserClicksByReferrer = `-- name: GetUserClicksByReferrer :many
SELECT
    ls.referrer,
    count(ls.id)::int as clicks
FROM link_stats ls
         JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.user_id = $1 AND ls.referrer IS NOT NULL AND ls.referrer != ''
GROUP BY ls.referrer
ORDER BY clicks DESC
LIMIT $2
`

type GetUserClicksByReferrerParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
}

type GetUserClicksByReferrerRow struct {
	Referrer *string `json:"referrer"`
	Clicks   int32   `json:"clicks"`
}

// Mengelompokkan jumlah klik berdasarkan sumber trafik (referrer) untuk semua link milik pengguna.
// Dibatasi dengan LIMIT untuk mengambil N sumber teratas.
func (q *Queries) GetUserClicksByReferrer(ctx context.Context, arg GetUserClicksByReferrerParams) ([]GetUserClicksByReferrerRow, error) {
	rows, err := q.db.Query(ctx, getUserClicksByReferrer, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserClicksByReferrerRow{}
	for rows.Next() {
		var i GetUserClicksByReferrerRow
		if err := rows.Scan(&i.Referrer, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDashboardStats = `-- name: GetUserDashboardStats :one
SELECT
    (SELECT count(*) FROM short_links WHERE user_id = $1)::int AS total_links,
    (SELECT count(ls.id)
     FROM link_stats ls
              JOIN short_links sl ON ls.link_id = sl.id
     WHERE sl.user_id = $1
    )::int AS total_clicks
`

type GetUserDashboardStatsRow struct {
	TotalLinks  int32 `json:"total_links"`
	TotalClicks int32 `json:"total_clicks"`
}

// Mengambil statistik ringkas untuk dashboard pengguna: jumlah total link dan jumlah total klik.
func (q *Queries) GetUserDashboardStats(ctx context.Context, userID pgtype.UUID) (GetUserDashboardStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserDashboardStats, userID)
	var i GetUserDashboardStatsRow
	err := row.Scan(&i.TotalLinks, &i.TotalClicks)
	return i, err
}

const getUserLinksWithStats = `-- name: GetUserLinksWithStats :many
SELECT
    sl.id,
    sl.short_code,
    sl.original_url,
    sl.title,
    sl.created_at,
    count(ls.id)::int as click_count
FROM short_links sl
         LEFT JOIN link_stats ls ON sl.id = ls.link_id
WHERE sl.user_id = $1
GROUP BY sl.id
ORDER BY sl.created_at DESC
LIMIT $2
    OFFSET $3
`

type GetUserLinksWithStatsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

type GetUserLinksWithStatsRow struct {
	ID          uuid.UUID        `json:"id"`
	ShortCode   string           `json:"short_code"`
	OriginalUrl string           `json:"original_url"`
	Title       *string          `json:"title"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	ClickCount  int32            `json:"click_count"`
}

// Mengambil daftar link milik pengguna beserta jumlah klik untuk setiap link, dengan paginasi.
// Menggunakan LEFT JOIN untuk memastikan link yang belum pernah diklik (0 klik) tetap muncul.
func (q *Queries) GetUserLinksWithStats(ctx context.Context, arg GetUserLinksWithStatsParams) ([]GetUserLinksWithStatsRow, error) {
	rows, err := q.db.Query(ctx, getUserLinksWithStats, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLinksWithStatsRow{}
	for rows.Next() {
		var i GetUserLinksWithStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.Title,
			&i.CreatedAt,
			&i.ClickCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
