// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: links_stats_user.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLinkStat = `-- name: CreateLinkStat :one
INSERT INTO link_stats (
    id,
    link_id,
    ip_address,
    user_agent,
    referrer,
    country,
    device_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, link_id, click_time, ip_address, user_agent, referrer, country, device_type
`

type CreateLinkStatParams struct {
	ID         uuid.UUID `json:"id"`
	LinkID     uuid.UUID `json:"link_id"`
	IpAddress  *string   `json:"ip_address"`
	UserAgent  *string   `json:"user_agent"`
	Referrer   *string   `json:"referrer"`
	Country    *string   `json:"country"`
	DeviceType *string   `json:"device_type"`
}

// Records a click event when someone accesses a short link with custom UUID v7
func (q *Queries) CreateLinkStat(ctx context.Context, arg CreateLinkStatParams) (LinkStat, error) {
	row := q.db.QueryRow(ctx, createLinkStat,
		arg.ID,
		arg.LinkID,
		arg.IpAddress,
		arg.UserAgent,
		arg.Referrer,
		arg.Country,
		arg.DeviceType,
	)
	var i LinkStat
	err := row.Scan(
		&i.ID,
		&i.LinkID,
		&i.ClickTime,
		&i.IpAddress,
		&i.UserAgent,
		&i.Referrer,
		&i.Country,
		&i.DeviceType,
	)
	return i, err
}

const getLinkStats = `-- name: GetLinkStats :many
SELECT
    ls.id, ls.link_id, ls.click_time, ls.ip_address,
    ls.user_agent, ls.referrer, ls.country, ls.device_type
FROM link_stats ls
JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.id = $1 AND sl.user_id = $2
ORDER BY ls.click_time DESC
LIMIT $3 OFFSET $4
`

type GetLinkStatsParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

// Returns all stats for a specific link owned by the user
func (q *Queries) GetLinkStats(ctx context.Context, arg GetLinkStatsParams) ([]LinkStat, error) {
	rows, err := q.db.Query(ctx, getLinkStats,
		arg.ID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LinkStat{}
	for rows.Next() {
		var i LinkStat
		if err := rows.Scan(
			&i.ID,
			&i.LinkID,
			&i.ClickTime,
			&i.IpAddress,
			&i.UserAgent,
			&i.Referrer,
			&i.Country,
			&i.DeviceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkStatsByDateRange = `-- name: GetLinkStatsByDateRange :many
SELECT
    ls.id, ls.link_id, ls.click_time, ls.ip_address,
    ls.user_agent, ls.referrer, ls.country, ls.device_type
FROM link_stats ls
JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.id = $1
  AND sl.user_id = $2
  AND ls.click_time BETWEEN $3 AND $4
ORDER BY ls.click_time DESC
`

type GetLinkStatsByDateRangeParams struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	ClickTime   pgtype.Timestamptz `json:"click_time"`
	ClickTime_2 pgtype.Timestamptz `json:"click_time_2"`
}

// Returns all stats for a specific link within a date range
func (q *Queries) GetLinkStatsByDateRange(ctx context.Context, arg GetLinkStatsByDateRangeParams) ([]LinkStat, error) {
	rows, err := q.db.Query(ctx, getLinkStatsByDateRange,
		arg.ID,
		arg.UserID,
		arg.ClickTime,
		arg.ClickTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LinkStat{}
	for rows.Next() {
		var i LinkStat
		if err := rows.Scan(
			&i.ID,
			&i.LinkID,
			&i.ClickTime,
			&i.IpAddress,
			&i.UserAgent,
			&i.Referrer,
			&i.Country,
			&i.DeviceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkStatsCount = `-- name: GetLinkStatsCount :one
SELECT COUNT(*)
FROM link_stats ls
JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.id = $1 AND sl.user_id = $2
`

type GetLinkStatsCountParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

// Returns the total count of stats entries for a specific link
func (q *Queries) GetLinkStatsCount(ctx context.Context, arg GetLinkStatsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getLinkStatsCount, arg.ID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLinkStatsGroupedByCountry = `-- name: GetLinkStatsGroupedByCountry :many
SELECT ls.country, COUNT(*) as clicks
FROM link_stats ls
JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.id = $1 AND sl.user_id = $2
GROUP BY ls.country
ORDER BY clicks DESC
`

type GetLinkStatsGroupedByCountryParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type GetLinkStatsGroupedByCountryRow struct {
	Country *string `json:"country"`
	Clicks  int64   `json:"clicks"`
}

// Returns stats grouped by country for a specific link
func (q *Queries) GetLinkStatsGroupedByCountry(ctx context.Context, arg GetLinkStatsGroupedByCountryParams) ([]GetLinkStatsGroupedByCountryRow, error) {
	rows, err := q.db.Query(ctx, getLinkStatsGroupedByCountry, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLinkStatsGroupedByCountryRow{}
	for rows.Next() {
		var i GetLinkStatsGroupedByCountryRow
		if err := rows.Scan(&i.Country, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkStatsGroupedByDate = `-- name: GetLinkStatsGroupedByDate :many
SELECT
    DATE(ls.click_time) as date,
    COUNT(*) as clicks
FROM link_stats ls
JOIN short_links sl ON ls.link_id = sl.id
WHERE sl.id = $1 AND sl.user_id = $2
GROUP BY DATE(ls.click_time)
ORDER BY date DESC
`

type GetLinkStatsGroupedByDateParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

type GetLinkStatsGroupedByDateRow struct {
	Date   pgtype.Date `json:"date"`
	Clicks int64       `json:"clicks"`
}

// Returns stats grouped by date for a specific link
func (q *Queries) GetLinkStatsGroupedByDate(ctx context.Context, arg GetLinkStatsGroupedByDateParams) ([]GetLinkStatsGroupedByDateRow, error) {
	rows, err := q.db.Query(ctx, getLinkStatsGroupedByDate, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLinkStatsGroupedByDateRow{}
	for rows.Next() {
		var i GetLinkStatsGroupedByDateRow
		if err := rows.Scan(&i.Date, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
